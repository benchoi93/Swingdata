<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swing Scooter Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background: #111;
            color: #fff;
        }

        #control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            width: 300px;
        }

        #map-container {
            width: 100vw;
            height: 100vh;
        }

        #error-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            z-index: 999;
            display: none;
            max-width: 80%;
        }
    </style>
    <!-- Use a specific, recent version of deck.gl that definitely includes TileLayer -->
    <script src="https://unpkg.com/deck.gl@8.9.33/dist.min.js"></script>

    <!-- Mapbox GL JS (needed if we use MapboxLayer, but we are using TileLayer here. 
         However, DeckGL might look for it. Keeping it safe.) -->
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css' rel='stylesheet' />
</head>

<body>
    <div id="error-display"></div>
    <script>
        window.onerror = function (message, source, lineno, colno, error) {
            const d = document.getElementById('error-display');
            d.style.display = 'block';
            d.innerText = "Error: " + message + "\nLine: " + lineno;
        };
    </script>
    <div id="control-panel">
        <h2>Swing Data</h2>
        <div id="stats">Loading stats...</div>

        <div style="margin: 15px 0;">
            <label style="display:block; font-size: 12px; color: #aaa;">Start Date</label>
            <input type="date" id="start-time"
                style="width: 100%; box-sizing: border-box; background: #333; color: white; border: 1px solid #555;">

            <label style="display:block; font-size: 12px; color: #aaa; margin-top: 5px;">End Date</label>
            <input type="date" id="end-time"
                style="width: 100%; box-sizing: border-box; background: #333; color: white; border: 1px solid #555;">

            <label style="display:block; font-size: 12px; color: #aaa; margin-top: 5px;">Safety Limit (Max
                Trips)</label>
            <input type="number" id="limit-val" value="1000000" min="1000" max="10000000" step="10000"
                style="width: 100%; box-sizing: border-box; background: #333; color: white; border: 1px solid #555;">

            <div style="margin-top: 10px; display:flex; align-items:center;">
                <input type="checkbox" id="region-filter" style="margin-right: 5px;" checked>
                <label for="region-filter" style="font-size: 12px; color: #aaa; cursor:pointer;">Restrict to Map
                    View</label>
            </div>
        </div>

        <button onclick="loadSample()"
            style="width: 100%; padding: 8px; cursor: pointer; background: #d35400; color: white; border: none; font-weight: bold;">Load
            Data in Range</button>
        <div id="load-status"
            style="margin-top: 10px; font-size: 13px; color: #ddd; text-align: center; min-height: 1.2em;"></div>

        <div id="progress-container" style="display:none; margin-top: 5px;">
            <progress id="fetch-progress" value="0" max="100" style="width:100%; height: 8px;"></progress>
            <div id="fetch-progress-text" style="font-size:10px; text-align:center; color:#aaa; margin-top:2px;"></div>
        </div>

        <hr style="border-color: #444; margin: 15px 0;">

        <!-- Animation Controls -->
        <div>
            <h3 style="margin: 5px 0;">Simulation</h3>
            <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                <button id="play-btn" onclick="togglePlay()" disabled
                    style="flex:1; padding: 5px; cursor: pointer; background: #27ae60; color: white; border: none;">Play</button>
                <button onclick="resetAnimation()"
                    style="padding: 5px; cursor: pointer; background: #555; color: white; border: none;">Reset</button>
            </div>

            <label style="display:block; font-size: 12px; color: #aaa;">Speed: <span id="speed-val">50x</span></label>
            <input type="range" id="speed-slider" min="0" max="4" step="0.1" value="1.7" style="width: 100%;"
                oninput="updateSpeedVal(this.value)">

            <label style="display:block; font-size: 12px; color: #aaa;">Time: <span
                    id="current-time-display">-</span></label>
            <input type="range" id="time-slider" min="0" max="100" value="0" step="0.1" style="width: 100%;"
                oninput="manualTimeChange()">
        </div>

        <div id="details-panel"></div>
    </div>
    <div id="map-container"></div>
    <script>
        // ... (rest of the script)
        // We will target the script block below to update functions

        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.zIndex = '1';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.background = 'rgba(0, 0, 0, 0.8)';
        tooltip.style.color = '#fff';
        tooltip.style.padding = '8px';
        tooltip.style.borderRadius = '4px';
        tooltip.style.fontSize = '12px';
        tooltip.style.display = 'none';
        document.body.appendChild(tooltip);

        // Helper to generate color from string
        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            // Generate distinct vibrant colors
            // HSL to RGB conversion roughly or just explicit RGB manipulation
            const h = Math.abs(hash) % 360;
            return hslToRgb(h / 360, 0.8, 0.6);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        const deckgl = new deck.DeckGL({
            container: 'map-container',
            initialViewState: {
                longitude: 126.9780,
                latitude: 37.5665,
                zoom: 11,
                pitch: 0,
                bearing: 0
            },
            onViewStateChange: ({ viewState }) => {
                currentViewState = viewState;
                deckgl.setProps({ viewState });
            },
            controller: true,
            layers: [
                // Background Layer (Carto Dark Matter)
                new deck.TileLayer({
                    id: 'map-layer',
                    data: 'https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    minZoom: 0,
                    maxZoom: 19,
                    tileSize: 256,
                    renderSubLayers: props => {
                        const {
                            bbox: { west, south, east, north }
                        } = props.tile;
                        return new deck.BitmapLayer(props, {
                            data: null,
                            image: props.data,
                            bounds: [west, south, east, north]
                        });
                    }
                })
            ]
        });

        // Animation State
        let loadedData = [];
        let timeRange = { min: 0, max: 0, duration: 0 };
        let animationTime = 0;
        let isPlaying = false;
        let animationFrameId = null;
        let lastFrameTime = 0;
        let currentViewState = {
            longitude: 126.9780,
            latitude: 37.5665,
            zoom: 11,
            pitch: 0,
            bearing: 0,
            width: window.innerWidth,
            height: window.innerHeight
        };

        function getMapBounds() {
            // Use WebMercatorViewport to calculate bounds
            const viewport = new deck.WebMercatorViewport(currentViewState);
            const bounds = viewport.getBounds();
            // bounds is [west, south, east, north]
            return {
                west: bounds[0],
                south: bounds[1],
                east: bounds[2],
                north: bounds[3]
            };
        }

        let playSpeed = 50; // multiplier (x real time)

        function formatTimestamp(ts) {
            return new Date(ts * 1000).toLocaleString();
        }

        // Helper to format date for input[type=date]
        function toLocalDate(dateStr) {
            if (!dateStr) return '';
            // backend sends ISO "YYYY-MM-DDTHH:MM:SS", we want "YYYY-MM-DD"
            return dateStr.substring(0, 10);
        }

        async function fetchStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                if (data.error) {
                    document.getElementById('stats').innerText = data.error;
                } else {
                    document.getElementById('stats').innerHTML = `
                        <strong>Total Records:</strong> ${data.total_records.toLocaleString()}<br>
                        <strong>Data Range:</strong><br>
                        ${data.start_date}<br>to ${data.end_date}
                    `;

                    // Auto-fill inputs if empty
                    const s = document.getElementById('start-time');
                    const e = document.getElementById('end-time');
                    if (!s.value && data.start_date) s.value = toLocalDate(data.start_date);
                    if (!e.value && data.end_date) e.value = toLocalDate(data.end_date);
                }
            } catch (err) {
                console.error(err);
            }
        }

        async function loadSample() {
            try {
                const btn = document.querySelector('button');
                btn.innerText = "Loading...";
                btn.disabled = true;
                const statusDiv = document.getElementById('load-status');
                statusDiv.innerText = "Fetching data...";
                statusDiv.style.color = "#ddd";

                // Show progress bar immediately (Query phase)
                const progressContainer = document.getElementById('progress-container');
                const progressBar = document.getElementById('fetch-progress');
                const progressText = document.getElementById('fetch-progress-text');

                progressContainer.style.display = 'block';
                progressBar.removeAttribute('value'); // Indeterminate
                progressText.innerText = "Querying Database...";

                // Get filter values
                const startVal = document.getElementById('start-time').value;
                const endVal = document.getElementById('end-time').value;
                const limit = document.getElementById('limit-val').value;

                // Construct URL
                // Append time to cover full days
                let url = `/api/sample?limit=${limit}`;
                if (startVal) url += `&start=${startVal} 00:00:00`;
                if (endVal) url += `&end=${endVal} 23:59:59`;

                // Region Filter
                if (document.getElementById('region-filter').checked) {
                    const bounds = getMapBounds();
                    url += `&north=${bounds.north}&south=${bounds.south}&east=${bounds.east}&west=${bounds.west}`;
                    console.log("Filtering by bounds:", bounds);
                }

                const response = await fetch(url);

                // --- Progress Bar Logic ---
                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');

                let receivedLength = 0;
                let chunks = [];

                // Update status to Downloading
                progressText.innerText = "Downloading...";

                progressContainer.style.display = 'block';
                progressBar.removeAttribute('value'); // Indeterminate if no content-length

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    chunks.push(value);
                    receivedLength += value.length;

                    if (contentLength) {
                        const percent = (receivedLength / contentLength) * 100;
                        progressBar.value = percent;
                        progressText.innerText = `${Math.round(percent)}% (${(receivedLength / 1024 / 1024).toFixed(1)} MB)`;
                    } else {
                        progressText.innerText = `${(receivedLength / 1024 / 1024).toFixed(1)} MB downloaded`;
                    }
                }

                // Hide progress bar
                progressContainer.style.display = 'none';
                statusDiv.innerText = "Parsing data...";

                // Assemble chunks
                let chunksAll = new Uint8Array(receivedLength);
                let position = 0;
                for (let chunk of chunks) {
                    chunksAll.set(chunk, position);
                    position += chunk.length;
                }

                // Decode and Parse values
                const text = new TextDecoder("utf-8").decode(chunksAll);
                const data = JSON.parse(text);

                if (data.error) {
                    alert("Error: " + data.error);
                    btn.innerText = "Load Data in Range";
                    btn.disabled = false;
                    return;
                }

                if (!data || data.length === 0) {
                    alert("No data found in this range.");
                    statusDiv.innerText = "No data found.";
                    statusDiv.style.color = "#e74c3c";
                    btn.innerText = "Load Data in Range";
                    btn.disabled = false;
                    return;
                }

                statusDiv.innerText = `Loaded ${data.length.toLocaleString()} trips`;
                statusDiv.style.color = "#2ecc71";

                // --- PREPARE DATA FOR ANIMATION ---
                let minTs = Infinity;
                let maxTs = -Infinity;

                // First pass: find global min/max timestamps
                // structure: d.path = [[ts, lat, lon], ...]
                for (const d of data) {
                    if (d.path && d.path.length > 0) {
                        const start = d.path[0][0];
                        const end = d.path[d.path.length - 1][0];
                        if (start < minTs) minTs = start;
                        if (end > maxTs) maxTs = end;
                    }
                }

                if (minTs === Infinity) {
                    alert("Data has no valid timestamps.");
                    btn.innerText = "Load Data in Range";
                    btn.disabled = false;
                    return;
                }

                // Set Time Range
                timeRange.min = minTs;
                timeRange.max = maxTs;
                timeRange.duration = maxTs - minTs;

                // Process data for Deck.gl
                // We want: trips = [[lon, lat, relative_ts], ...]
                loadedData = data.map(d => {
                    const trips = d.path.map(p => {
                        // p = [ts, lat, lon]
                        // We need [lon, lat, relative_ts]
                        return [p[2], p[1], p[0] - minTs];
                    });
                    return {
                        ...d, // keep route_id, etc.
                        trips: trips
                    };
                });

                // Update UI Controls
                const timeSlider = document.getElementById('time-slider');
                timeSlider.max = timeRange.duration;
                timeSlider.value = 0;

                document.getElementById('play-btn').disabled = false;

                // Re-center view
                if (loadedData.length > 0 && loadedData[0].trips.length > 0) {
                    const firstPt = loadedData[0].trips[0];
                    deckgl.setProps({
                        initialViewState: {
                            longitude: firstPt[0],
                            latitude: firstPt[1],
                            zoom: 13,
                            transitionDuration: 1000,
                            transitionInterpolator: new deck.FlyToInterpolator()
                        }
                    });
                }

                // Reset animation state
                resetAnimation();

                btn.innerText = "Load Data in Range";
                btn.disabled = false;

            } catch (err) {
                console.error(err);
                alert("Failed to load sample data: " + err);
                document.querySelector('button').innerText = "Load Data in Range";
                document.querySelector('button').disabled = false;
            }
        }

        // --- Animation Logic ---

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').innerText = isPlaying ? "Pause" : "Play";
            document.getElementById('play-btn').style.background = isPlaying ? "#e74c3c" : "#27ae60";

            if (isPlaying) {
                lastFrameTime = performance.now();
                animate();
            } else {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
            }
        }

        function resetAnimation() {
            isPlaying = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationTime = 0;
            document.getElementById('time-slider').value = 0;
            document.getElementById('play-btn').innerText = "Play";
            document.getElementById('play-btn').style.background = "#27ae60";
            updateTimeDisplay();
            renderLayers();
        }

        function manualTimeChange() {
            animationTime = parseFloat(document.getElementById('time-slider').value);
            updateTimeDisplay();
            renderLayers();
        }

        function updateTimeDisplay() {
            // Display absolute time
            const currentTs = timeRange.min + animationTime;
            document.getElementById('current-time-display').innerText = formatTimestamp(currentTs);
        }

        function animate() {
            if (!isPlaying) return;

            const now = performance.now();
            const dt = (now - lastFrameTime) / 1000; // seconds
            lastFrameTime = now;

            // Speed control
            // Logarithmic scale: 10^slider_val
            const sliderVal = parseFloat(document.getElementById('speed-slider').value);
            playSpeed = Math.pow(10, sliderVal);
            document.getElementById('speed-val').innerText = Math.round(playSpeed).toLocaleString() + "x";

            animationTime += dt * playSpeed;

            // Loop
            if (animationTime > timeRange.duration) {
                animationTime = 0;
            }

            document.getElementById('time-slider').value = animationTime;
            updateTimeDisplay();
            renderLayers();

            animationFrameId = requestAnimationFrame(animate);
        }

        function updateSpeedVal(val) {
            const speed = Math.pow(10, val);
            document.getElementById('speed-val').innerText = Math.round(speed).toLocaleString() + "x";
        }

        function renderLayers() {
            // TRAIL_LENGTH in seconds (e.g., 300s = 5 mins)
            const TRAIL_LENGTH = 300;

            const layers = [
                new deck.TileLayer({
                    id: 'base-map-layer',
                    data: 'https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    minZoom: 0,
                    maxZoom: 19,
                    tileSize: 256,
                    renderSubLayers: props => {
                        const { bbox: { west, south, east, north } } = props.tile;
                        return new deck.BitmapLayer(props, {
                            data: null,
                            image: props.data,
                            bounds: [west, south, east, north]
                        });
                    }
                })
            ];

            if (loadedData.length > 0) {
                layers.push(
                    new deck.TripsLayer({
                        id: 'trips-layer',
                        data: loadedData,
                        getPath: d => d.trips,
                        // each point in trips matches [lon, lat, relative_ts]
                        getTimestamps: d => d.trips.map(p => p[2]),
                        getColor: d => stringToColor(d.route_id),
                        opacity: 0.8,
                        widthMinPixels: 4,
                        rounded: true,
                        trailLength: TRAIL_LENGTH,
                        currentTime: animationTime,
                        shadowEnabled: false,
                        pickable: true,
                        autoHighlight: true,
                        highlightColor: [255, 255, 255, 255],
                        onHover: info => {
                            if (info.object) {
                                tooltip.style.display = 'block';
                                tooltip.style.left = info.x + 'px';
                                tooltip.style.top = info.y + 'px';
                                tooltip.innerText = `Route: ${info.object.route_id}`;
                            } else {
                                tooltip.style.display = 'none';
                            }
                        },
                        onClick: info => {
                            if (info.object) {
                                const d = info.object;
                                const details = `
                                    <h3>Selected Route</h3>
                                    <p><b>ID:</b> ${d.route_id}</p>
                                    <p><b>Start:</b> ${d.start_timestamp}</p>
                                    <p><b>End:</b> ${d.end_timestamp}</p>
                                    <p><b>Points:</b> ${d.path.length}</p>
                                `;
                                const div = document.getElementById('details-panel');
                                if (div) div.innerHTML = details;
                            }
                        }
                    })
                );
            }

            deckgl.setProps({ layers });
        }

        fetchStats();
    </script>
</body>

</html>